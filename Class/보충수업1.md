02/27

## 알고리즘 기초

1~100 이하의 정수들. 여기서 힌트를 얻어야지. 범위가 정해져있다. => 카운팅 정렬

이런 문제 형식을 무엇이라고 한다? brute force는 설계기법이고, "최적해 구하는 문제"지.



03/06

## 배열

#### 배열 탐색

파이썬은 리스트지만, 일반적으로 배열이라고 한다. 배열을 탐색할 때 기본적인 패턴들을 볼 것이다. 순방향과 역방향으로 하나씩 읽으면서 처리할 수 있다. 기준이 되는 것부터 다음거를 동시에 읽으면서 일처리하는 문제도 있었다. => **오르막길**은 자료가 1차원으로 주어진다. 계속 증가하는 형태를 체크해야한다. 오르막이 시작하는 값과 오르막이 끝나는 값을 찾으면 된다. for문 돌릴 때 하나씩 읽는 게 아니라 두 개씩 혹은 세 개씩 혹은 필요한 일정한 간격을 두고 읽도록 하면 된다. 이런 문제는 너무 쉬워서 IM 으로 나오지는 않겠지만 이걸 2차 배열 형태로 주고 가로 세로로 다 조사하게 낼 수 있다.

n 길이 배열에서 m 길이 구간 탐색. 어디에 있는지 모르는데 찾아야하면 제일 쉬운 방법은 다 찾아보는 것이다. 처음 있을 수 있는 길이 m부터 길이 m에 해당하는 구간을 다 찾으면 된다. 구간 길이 m의 시작과 끝을 생각하면 쉽게 찾을 수 있다. 0부터 n-1이면 마지막 시작 위치는 n-m이 된다. 결국 만들어낼 구간의 시작 위치를 0부터 n-m까지 반복하면서 하면 된다. 끝나는 위치도 알 수 있다. start = 0~n-m, end = start + m-1  => 첫 날 푼 구간합과 길이가 n인 회문 찾기

연속적인 구간이긴 하지만 길이가 안 정해진 경우. 조사해야될 문자의 시작하는 위치와 끝나는 위치를 알면 문제를 쉽게 풀 수 있다. 답이 어디있는지 모르는데, 길이가 고정적이지 않다. 그러면 답이 될 가능성이 있는 모든 경우를 체크해야하니까 모든 길이에 대해서 다 해봐야한다. 시작 위치를 늘리거나 끝나는 위치를 줄여간다. => 회문 2 (길이가 최대가 되는 회문을 찾는 것) 최소 1~N

대각선 탐색. m by n 일 때 사선의 개수는? N+M-1만큼 있다. 행값을 늘리고, 열 값을 줄여간다. 그리고 경계체크를 하면 된다. 바깥에 for문 내부에 while문을 쓰면 구현이 될 것이다. 

```python
N, M = len(arr), len(arr[0])
for diag in range(0, N+M-1):
    x = 0 if diag < M else (diag-M+1) # 0부터 5까지는 행값이 0으로 설정되고, 열 값은 늘어난다.
    y = diag if diag < M else M-1 # 5부터는 행값이 늘어난다.
    
    while x < N and y >= 0: # 그 다음부터는 심플하다. 경계만 체크하면 된다.
        print('%2d ' %)
        x += 1
        y -= 1
    print()
```

사각 영역 탐색. 5x5 영역에서 3x3 영역을 탐색해야한다. 반복을 할 때, 1차배열에서 했던 것 처럼 전체 길이가 n이고, 사각형의 길이가 m이면 n-m까지밖에 못 간다. 그러면 시작점들만 모은 사각 영역이 또 나온다. 

| 0,0    | 0, n-m   |
| ------ | -------- |
| n-m, 0 | n-m, n-m |

```python
for i in range(N-M +1):
    for j in range(N-M+1): # 정사각형이 아니면 시작 위치도 조정
# i, j가 시작하는 좌표이다. 행에 대해서는 여기까지, 열에 대해서는 여기까지

# 시작위치를 알면 행와 열에 대해서
		for x in range(i, i+M):
        	for y in range(j, j+M):
                print('%2d ' %arr[x][y], end='')
            print()
```



#### 분할

2분할 하는 것은 쉽다. 한쪽이 하나 이상이기만 하면 된다. 쪼갤 수 있는 모든 경우에 대해서 다 한다. 두 구간의 시작과 끝 인덱스를 만들어낸다고 생각하면 된다. (0, 0) 시작과 끝이 같으면 1개이다. 그러면 그 뒤 값은 +1하면 자동으로 나온다. (0,0)(1,9)이런 식 (0, 4)(5,9) c 스타일은 왼쪽을 기준으로 하는게 좋은데, 파이썬은 for문 돌리기 위해서 오른쪽이 더 편하다. for문을 2개 써서 3개의 영역으로 분할할 수 있다. => SW에 러시아 국기같은 깃발(문제번호 4613) 이게 3분할 하는 문제이다. 블랙잭 문제 보면 3개의 숫자를 골라내야 한다. for문으로 중첩해서 조합을 만든다. 분할도 결국은 조합이다. 3 영역으로 나누면 결국 나누는 위치 2 군데를 뽑아내면 된다. 2군데를 고르면 나머지 위치를 고를 수 있다. 첫번째 영역이 끝나는 인덱스, 두번째 영역이 끝나는 인덱스 아니면 두번째 시작, 세번째 영역 시작을 할면 세 부분으로 나눌 수 있다. 0과 끝나는 점은 이미 우리가 알고 있으니까! (0, 0)(1, 5)(6, 9) 두 번째 영역 시작은 1부터 (앞에 적어도 1개는 있어야하니까) 1부터 뒤에 적어도 하나가 있어야하니까 n-2까지 간다. 세번째 거 시작은 두번째 영역의 시작 다음위치부터 n-1까지로 하면 된다. 

```python
arr = [x for x in range(7)]
N = len(arr)

for i in range(1, N-1): # 두번째 영역의 시작하는 위치
    for j in range(i+1, N): #세번째 영역의 시작한는 위치
        print(arr[0: i], end='||')
        print(arr[i: j], end='||')
        print(arr[j: N])
```

러시아 국기. 열의 크기 고정되고 행의 크기가 가변적일 때 3개가 들어온다. 



아까 분할하기의 응용버전. im은 나올 가능성 없고, AD에서 나올 수 있다.

2차 배열 형태에 이런 모양으로 나누고 싶다. 길게 하나가 있고, 옆으로 두는게 2개 있다. 적어도 가로 세로의 길이는 1이 되게 하고 싶은 것이다.

| 여기서부터 (0,0)             | (0,i+1) 에서 (j, N-1)     |
| ---------------------------- | ------------------------- |
| 여기까지 세로로 길게(N-1, i) | (j+1, i+1)에서 (N-1, N-1) |

수직으로 나누는 위치와 수평으로 나누는 위치를 다 만들어서 일을 해야한다. i는 어디서부터 어디까지 갈 수 있고, j도 어디서부터 어디까지 갈 수 있는지 본다. 좌상단과 우하단만 알면 좌표를 계산해서 사용할 수 있다. 

알면 쉬운 문제인데, 처음에 보면 for문 중첩되서 못 푼다.