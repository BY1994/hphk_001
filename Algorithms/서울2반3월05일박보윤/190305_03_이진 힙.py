"""
5177. [파이썬 S/W 문제해결 기본] 8일차 - 이진 힙
이진 최소힙은 다음과 같은 특징을 가진다.
    - 항상 완전 이진 트리를 유지하기 위해 마지막 노드 뒤에 새 노드를 추가한다.
    - 부모 노드의 값<자식 노드의 값을 유지한다. 새로 추가된 노드의 값이 조건에 맞지 않는 경우, 조건을 만족할 때까지 부모 노드와 값을 바꾼다.
    - 노드 번호는 루트가 1번, 왼쪽에서 오른쪽으로, 더 이상 오른쪽이 없는 경우 다음 줄로 1씩 증가한다.
예를 들어 7, 2, 5, 3, 4, 6이 차례로 입력되면 다음과 같은 트리가 구성된다.
이때 마지막 노드인 6번의 조상은 3번과 1번 노드이다.
1000000이하인 N개의 서로 다른 자연수가 주어지면 입력 순서대로 이진 최소힙에 저장하고, 마지막 노드의 조상 노드에 저장된 정수의 합을 알아내는 프로그램을 작성하시오.

[입력]
첫 줄에 테스트케이스의 수 T가 주어진다. 1<=T<=50
다음 줄부터 테스트 케이스의 별로 N이 주어지고, 다음 줄에 1000000이하인 서로 다른 N개의 자연수가 주어진다. 5<=N<=500

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

2019.03.04 PBY 최초작성
2019.03.05 최종제출
"""

import sys
sys.stdin = open('C:/Users/student/Documents/week2/day1/Algorithms/190305_03_input.txt', 'r')


T = int(input())
for tc in range(T):

    N = int(input())
    numbers = list(map(int, input().split()))

    # 우선 순위 큐
    q = [0 for i in range(N+1)]
    
    for nid in range(1,N+1): # 개수가 계속 들어오면
        # 숫자가 하나씩 들어오면서 우선순위 큐에 들어감
        q[nid] = numbers[nid-1]
        
        # 그리고 힙 정렬
        tempid = nid
        while True:
            # 내가 부모노드보다 작으면 부모 노드와 자리 바꾸기
            if q[tempid] <= q[tempid//2] and tempid != 1: # 부모 노드가 없는 1번의 경우
                q[tempid],q[tempid//2] = q[tempid//2],q[tempid]
            else:
                break
            tempid //= 2 # 부모 노드로 타고 들어가기 => 이걸 안해서 자리바꾸기를 한 번 밖에 안 했다...

    # 마지막 노드 조상의 합
    # N부터 계속 //2 해서 가면서 구하기
    anc_sum = 0
    while N > 1:
        anc_sum += q[N//2]
        N //= 2
        
    # 결과 출력
    print("#%d %d" %(tc+1,anc_sum))
    

"""
190305 # 1차시도: 테스트 케이스 3개 맞음
=> 힙의 자료구조가 맞는지 확인할 때 while문을 한 번 밖에 안 갔다.
부모 노드로 타고 들어가도록 index값을 조정 안 해줬다...
=> 해결!
"""


"""
190305 구현 방식 메모
어제 힙정렬을 하려면 아래에서 올라갔다가 또 위에서 다시 내려와야된다고 복잡하게 생각했는데,
이거는 삭제를 구현하지 않기 때문에 그냥 밑에 추가했을 때 부모랑 비교해서 위로 올리면
되는 거였다.
부모 노드인 1번을 만날 때까지 while 문을 돌게 했고,
마지막 조상 노드의 합은 부모 노드가 //2인 것을 활용해서 또 while문으로 그 위치의 모든
값을 sum하도록 하였다.
"""
